#!/usr/bin/env ruby

# Copyright (C) 2010 Red Hat, Inc.
# Written by Chris Lalancette <clalance@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.  A copy of the GNU General Public License is
# also available at http://www.gnu.org/copyleft/gpl.html.

$: << File.join(File.dirname(__FILE__), "../dutils")
$: << File.join(File.dirname(__FILE__), "../config")

require 'rubygems'
require 'optparse'
require 'socket'
require 'dutils'

port = 7890
help = false
daemon = true
refreshd_log_dir = "/var/log/aeolus-conductor"
refreshd_pid_dir = "/var/run/aeolus-conductor"
timeout = 5

optparse = OptionParser.new do |opts|

  opts.banner = <<BANNER
Usage: condor_refreshd [options]

Options:
BANNER
  opts.on( '-f', '--pid-file PATH', "Use PATH to the condor_refreshd pid directory (defaults to #{refreshd_pid_dir})") do |newpath|
    refreshd_pid_dir = newpath
  end
  opts.on( '-h', '--help', '') { help = true }
  opts.on( '-l', '--log PATH', "Use PATH to the condor_refreshd log directory (defaults to #{refreshd_log_dir}).  Use '-' for stdout") do |newpath|
    refreshd_log_dir = newpath
  end
  opts.on( '-n', '--nodaemon', 'Do not daemonize (useful in combination with -l for debugging)') { daemon = false }
  opts.on( '-p', '--port PORT', 'Use PORT (default: 7890)') do |newport|
    port = newport
  end
  opts.on( '-t', '--timeout TIMEOUT', 'Automatically refresh classads after TIMEOUT minutes') do |newtime|
    timeout = newtime
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  puts "Invalid option #{e.args}"
  puts
  puts optparse
  exit(1)
end

if help
  puts optparse
  exit(0)
end

# setup the logger
if refreshd_log_dir == '-'
  REFRESHD_LOG_FILE = STDOUT
else
  REFRESHD_LOG_FILE = File.open("#{refreshd_log_dir}/condor_refreshd.log", "a")
end
REFRESHD_LOG_FILE.sync = true
logger = Logger.new(REFRESHD_LOG_FILE)
logger.level = Logger::DEBUG

logger.info "Starting condor_refreshd..."
socket = Socket.new(Socket::AF_INET, Socket::SOCK_DGRAM, 0)
in_addr = Socket.pack_sockaddr_in(port, '127.0.0.1')
socket.bind(in_addr)

# daemonize
if daemon
  Process.daemon
end

begin
  REFRESHD_PID_FILE = "#{refreshd_pid_dir}/condor_refreshd.pid"
  FileUtils.mkdir_p File.dirname(REFRESHD_PID_FILE)
  open(REFRESHD_PID_FILE, "w") {|f| f.write(Process.pid) }
  File.chmod(0644, REFRESHD_PID_FILE)

  while true
    begin
      condormatic_classads_sync
      results = select([socket], nil, nil, timeout * 60)

      # if results was nil, we timed out waiting, and we need to do a sync
      # but not read from the socket
      if not results.nil? and results[0][0] == socket
        socket.recvfrom(1024)
        logger.info "Doing classad sync after getting data from the socket"
      else
        logger.info "Doing classad sync after timeout"
      end
    rescue => e
      logger.error "#{e.backtrace.shift}: #{e.message}"
      e.backtrace.each do |step|
        logger.error "\tfrom #{step}"
      end
    end
  end
rescue => e
  logger.error "#{e.backtrace.shift}: #{e.message}"
  e.backtrace.each do |step|
    logger.error "\tfrom #{step}"
  end
end
