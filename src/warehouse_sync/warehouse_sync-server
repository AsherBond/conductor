#!/usr/bin/ruby

$: << File.dirname(__FILE__)

require 'rubygems'
require 'optparse'
require 'warehouse_sync'

DELAY = 2
WAREHOUSE_CONFIG = YAML.load_file(File.join(File.dirname(__FILE__), "../config/image_warehouse.yml"))

# show timestamp in log file
class Logger
  def format_message(severity, timestamp, progname, msg)
    time = timestamp.getutc.strftime("%Y-%m-%d %H:%M:%S")
    "\n#{time}:#{severity.to_s.upcase}: #{msg}"
  end
end

help = false
daemon = true
log_dir        =   "/var/log/aeolus-conductor"
pid_dir        =   "/var/run/aeolus-conductor"

optparse = OptionParser.new do |opts|

  opts.banner = <<BANNER
Usage:
warehouse_sync [options]

Options:
BANNER
  opts.on( '-f', '--pid-file PATH', "Use PATH to the warehouse_sync pid directory (defaults to #{pid_dir})") do |newpath|
    pid_dir = newpath
  end
  opts.on( '-h', '--help', '') { help = true }
  opts.on( '-l', '--log PATH', "Use PATH to the warehouse_sync log directory (defaults to #{log_dir}).  Use '-' for stdout") do |newpath|
    log_dir = newpath
  end
  opts.on( '-n', '--nodaemon', 'Do not daemonize (useful in combination with -l for debugging)') { daemon = false }
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  puts "Invalid option #{e.args}"
  puts
  puts optparse
  exit(1)
end

if help
  puts optparse
  exit(0)
end

if log_dir == '-'
  LOG_FILE = STDOUT
else
  LOG_FILE = "#{log_dir}/warehouse_sync.log"
end

logger = Logger.new(LOG_FILE)
logger.level = Logger::INFO
logger.datetime_format = "%Y-%m-%d %H:%M:%S"
logger.info "Warehouse_sync starting up"

def create_pid_file(file)
  FileUtils.mkdir_p File.dirname(file)
  open(file, "w") {|f| f.write(Process.pid) }
  File.chmod(0644, file)
end

# daemonize
if daemon
  # note that this requires 'active_support', which we get for free from dutils
  Process.daemon
end

begin
  create_pid_file("#{pid_dir}/warehouse_sync.pid")
  WarehouseSync.new(:uri => WAREHOUSE_CONFIG['baseurl'], :logger => logger, :delay => DELAY * 60).run
rescue Exception => e
  logger.error "#{e.backtrace.shift}: #{e.message}"
  e.backtrace.each do |step|
    logger.error "\tfrom #{step}"
  end
  exit 1
end
