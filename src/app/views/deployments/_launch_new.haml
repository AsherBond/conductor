= if request.xhr?
  = render :partial => '/layouts/new_notification'
%header.page-header
  %h1{:class => controller.controller_name}
    New Deployment in
    = @pool.name
  #obj_actions.button-container
    = link_to 'Cancel', pool_path(@pool), :class => 'button danger', :id => 'cancel_deployment_button'
  .corner &nbsp;

%section.content-section.deployment
  %header
    %h2
      Deployment Details

  .content
    - form_for :deployment, {:url => new_deployment_path, :method => :get} do
      = hidden_field :deployment, :pool_id
      %p
        What do you want to launch?
      %p
        Select the Deployable definition
        = select_tag :suggested_deployable_id, options_for_select([['custom -- type bellow', 'custom']] + @suggested_deployables.map {|d| [d.name, d.id]}, params[:suggested_deployable_id])
      %p
        Or provide the URL of the Deployable definition
        = text_field('deployable', 'url')
      %p
        Name your deployment
        = text_field(:deployment, :name)
        %span.name_available
      %p
        Choose a realm
        = select :deployment, :frontend_realm_id, @realms.map{|r| [r.name, r.id]}, :include_blank => true
      = submit_tag 'Next', :class => 'button'

:javascript
  // FIXME: This has a theoretical race condition: if responses come back out of order, the value
  // might reflect some previous entry and tell you a name is available when it's not.
  // Might be nice to build something in application.js to guard against this, and that also
  // introduces a ~250ms buffer so we don't do a lookup on every single keystroke...
  $(document).ready(function () {
    $('#deployment_name').keyup(function(e) {
      e.preventDefault();
      $.get('#{check_name_deployments_path}', {name: $('#deployment_name').val() }, function(data) {
        $('.name_available').html(data == "false" ? "That name is already in use" : "Name available");
      });
    });
  });
