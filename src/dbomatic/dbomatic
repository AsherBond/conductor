#!/usr/bin/ruby
# Copyright (C) 2010 Red Hat, Inc.
# Written by Mohammed Morsi <mmorsi@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.  A copy of the GNU General Public License is
# also available at http://www.gnu.org/copyleft/gpl.html.

$: << File.join(File.dirname(__FILE__), "../dutils")

require 'rubygems'
require 'dutils'
require 'nokogiri'
require 'optparse'

help = false
daemon = true
condor_event_log_dir    =   "/var/log/condor"
dbomatic_run_dir        =   "/var/run/aeolus-conductor"
dbomatic_log_dir        =   "/var/log/aeolus-conductor"
dbomatic_pid_dir        =   "/var/run/aeolus-conductor"

optparse = OptionParser.new do |opts|

  opts.banner = <<BANNER
Usage:
dbomatic [options]

Options:
BANNER
  opts.on( '-f', '--pid-file PATH', "Use PATH to the dbomatic pid directory (defaults to #{dbomatic_pid_dir})") do |newpath|
    dbomatic_pid_dir = newpath
  end
  opts.on( '-h', '--help', '') { help = true }
  opts.on( '-l', '--log PATH', "Use PATH to the dbomatic log directory (defaults to #{dbomatic_log_dir}).  Use '-' for stdout") do |newpath|
    dbomatic_log_dir = newpath
  end
  opts.on( '-n', '--nodaemon', 'Do not daemonize (useful in combination with -l for debugging)') { daemon = false }
  opts.on( '-p', '--path PATH', "Use PATH to the condor log directory (defaults to #{condor_event_log_dir})") do |newpath|
    condor_event_log_dir = newpath
  end
  opts.on( '-r', '--run PATH', "Use PATH to the dbomatic runtime directory (defaults to #{dbomatic_run_dir})") do |newpath|
    dbomatic_run_dir = newpath
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  puts "Invalid option #{e.args}"
  puts
  puts optparse
  exit(1)
end

if help
  puts optparse
  exit(0)
end

CONDOR_EVENT_LOG_FILE       =   "#{condor_event_log_dir}/EventLog"
CONDOR_EVENT_LOG_FILE_OLD   =   "#{condor_event_log_dir}/EventLog.old"
EVENT_LOG_POS_FILE          =   "#{dbomatic_run_dir}/event_log_position"
if dbomatic_log_dir == '-'
  DBOMATIC_LOG_FILE        = STDOUT
  DBOMATIC_PARSER_LOG_FILE = STDOUT
else
  DBOMATIC_LOG_FILE        = "#{dbomatic_log_dir}/dbomatic.log"
  DBOMATIC_PARSER_LOG_FILE = "#{dbomatic_log_dir}/dbomatic-parser.log"
end

# daemonize
if daemon
  # note that this requires 'active_support', which we get for free from dutils
  Process.daemon
end

# Custom Log Format
class DBomaticLogger < Logger
  def format_message(severity, timestamp, progname, msg)
    "#{timestamp.to_formatted_s(:db)} #{severity} #{msg}\n"
  end
end

# Handle the event log's xml
class CondorEventLog < Nokogiri::XML::SAX::Document
  attr_accessor :tag, :event_type, :event_cmd, :event_time, :trigger_type, :grid_resource, :execute_host, :username, :hold_reason, :private_addresses, :public_addresses

  def initialize
    @logger       = DBomaticLogger.new(DBOMATIC_PARSER_LOG_FILE)
    @logger.level = Logger::DEBUG
    @logger.info    "DBOmatic parser starting up"
  end

  # Store the name of the event log attribute we're looking at
  def start_element(element, attributes)
    @tag = attributes[1] if element == "a"
  end

  # Store the value of the event log attribute we're looking at
  def characters(string)
    unless string.strip == ""
      if @tag == "MyType"
        @event_type = string
      elsif @tag == "Cmd"
        @event_cmd = string
      elsif @tag == "EventTime"
        @event_time = string
      elsif @tag == "TriggerEventTypeName"
        @trigger_type = string
      elsif @tag == "GridResource"
        @grid_resource = string
      elsif @tag == "ExecuteHost"
        @execute_host = string
      elsif @tag == "DeltacloudUsername"
        @username = string
      elsif @tag == "HoldReason"
        @hold_reason = string
      elsif @tag == "DeltacloudPublicNetworkAddresses"
        @public_addresses = string
      elsif @tag == "DeltacloudPrivateNetworkAddresses"
        @private_addresses = string
      end
    end
  end

  def update_instance_state_event(inst)
    @logger.info "update_instance_state_event for #{inst}"

    if @trigger_type == "ULOG_GRID_SUBMIT"
      inst.state = Instance::STATE_PENDING
    elsif @trigger_type == "ULOG_JOB_ABORTED" or @trigger_type == "ULOG_JOB_TERMINATED"
      inst.state = Instance::STATE_STOPPED
    elsif @trigger_type == "ULOG_EXECUTE"
      inst.state = Instance::STATE_RUNNING
    elsif @trigger_type == "ULOG_SUBMIT"
      # ULOG_SUBMIT happens when the job is first submitted to condor.
      # However, it's not a state that we care to export to users, but it's
      # also not an error, so we just silently ignore it.
    elsif @trigger_type == "ULOG_JOB_HELD"
      # The job has some error condition.
      #
      # FIXME: we also may want to delete this job from condor, depending
      # on the error.  For instance, if you are trying to start an instance
      # with a mismatched image and hardwareprofile architecture, the only
      # reasonable way out is to create a new instance.  Needs thought.
      #  - I've added a condormatic_instance_reset_error() method to reset
      #    error conditions such as this.  In the future we should give different
      #    options based on the error condition.
      # FIXME: Right now we don't parse out the HoldReason (or HoldReasonCode)
      # so for now I'm going to set this to STATE_ERROR as there are multiple
      # possible reasons for going into the 'held' state.
      #
      # FIXME: This only adds the error to the instance 'last_error' field.  We
      # should really be logging this information into the event log but that is not
      # set up at this time so for now this will do.
      inst.last_error = @hold_reason
      inst.state = Instance::STATE_ERROR
    else
      @logger.warn "Unexpected trigger type #{@trigger_type}, not updating instance state"
      return
    end

    begin
      @logger.info "update_instance_state_event saving instance #{inst}"
      inst.save!
      @logger.debug "updated_instance_state_event saved instance #{inst}, creating event for state #{inst.state}@#{@event_time}"
      inst.events.create!(:status_code => inst.state,
                          :event_time  => @event_time)
    rescue Exception => e
      @logger.error "#{e.backtrace.shift}: #{e.message}"
      e.backtrace.each do |step|
        @logger.error "\tfrom #{step}"
      end
    end

    @logger.info "update_instance_state_event completed fo #{inst}"
  end

  def update_instance_cloud_id(inst)
    @logger.info "update_instance_cloud_id for #{inst}"

    # The GridResource/ExecuteHost string looks like this:
    # dcloud http://localhost:3001/api

    if !@grid_resource.nil?
      resource = @grid_resource
    elsif !@execute_host.nil?
      resource = @execute_host
    else
      @logger.warn "Unexpected nil GridResource/ExecuteHost field, skipping cloud id update"
      return
    end

    args = resource.split
    link = args[1]

    if link.nil?
      @logger.error "Unexpected nil data from #{resource}, skipping cloud id update"
      return
    end
    if @username.nil?
      @logger.error "Unexpected nil username, skipping cloud id update"
      return
    end

    provider = Provider.find(:first, :conditions => ['url = ?', link])
    if provider.nil?
      @logger.error "Could not find the provider with link #{link}, skipping cloud id update"
      return
    end

    provider_account = provider.provider_accounts.detect {|a| a.credentials_hash['username'] == @username}
    if provider_account.nil?
      @logger.error "Could not find the cloud account corresponding to #{link} - #{@username}, skipping cloud id update"
      return
    end

    @logger.info "update_instance_cloud_id updating instance #{inst} to cloud provider #{provider}"
    inst.provider_account_id = provider_account.id

    inst.save!
    @logger.info "update_instance_cloud_id completed for #{inst}"
  end

  def update_instance_addresses(inst)
    @logger.info "update_instance_addresses for #{inst}, \
                  setting public addresses: #{@public_addresses} \
                  --- and private addresses #{private_addresses}"

    inst.public_addresses = @public_addresses
    inst.private_addresses = @private_addresses
    inst.save!
    @logger.info "update_instance_addresses completed for #{inst}"
  end

  # Create a new entry for events which we have all the neccessary data for
  def end_element(element)
    begin
      if element == "c" and @event_type == "JobAdInformationEvent" and !@trigger_type.nil?

        inst = Instance.find(:first, :conditions => ['condor_job_id = ?', @event_cmd])
        if inst.nil?
          @logger.warn "Unexpected nil instance, skipping..."
        else
          @logger.info "Instance #{inst} found, running update events"
          update_instance_state_event(inst)
          update_instance_cloud_id(inst)
          update_instance_addresses(inst)
          @logger.info "Instance #{inst} update events completed"
        end
        @tag = @event_type = @event_cmd = @event_time = @trigger_type = @grid_resource = @execute_host = @hold_reason = @public_addresses = @private_addresses = nil
      end
    rescue Exception => e
      @logger.error "#{e.backtrace.shift}: #{e.message}"
      e.backtrace.each do |step|
        @logger.error "\tfrom #{step}"
      end
    end
  end
end

# FIXME we should make sure everything here is done atomically
def parse_log_file(parser)
  # since the actual log file may be rotated out
  # open a new handle every time we want to parse
  log_file = File.open(CONDOR_EVENT_LOG_FILE)

  # persistantly store log position in filesystem
  # incase of dbomatic restarts
  if File.exists?(EVENT_LOG_POS_FILE)
    File.open(EVENT_LOG_POS_FILE, 'r') { |f| log_file.pos = f.read.to_i }
  end

  # if the log has been rotated out
  if log_file.pos > File.size(CONDOR_EVENT_LOG_FILE)
    if File.exists?(CONDOR_EVENT_LOG_FILE_OLD)
      # finish parsing old log file
      old_log_file = File.open(CONDOR_EVENT_LOG_FILE_OLD)
      old_log_file.pos = log_file.pos
      while s = old_log_file.gets
        parser << s
      end
    end

    # reset position
    log_file.pos = 0
  end

  while s = log_file.gets
    parser << s
  end

  File.open(EVENT_LOG_POS_FILE, 'w') { |f| f.write log_file.pos.to_s }
end

logger = DBomaticLogger.new(DBOMATIC_LOG_FILE)
logger.level = Logger::DEBUG
logger.datetime_format = "%Y-%m-%d %H:%M "  # simplify time output
logger.info "DBOmatic starting up"

begin
  DBOMATIC_PID_FILE = "#{dbomatic_pid_dir}/dbomatic.pid"
  FileUtils.mkdir_p File.dirname(DBOMATIC_PID_FILE)
  open(DBOMATIC_PID_FILE, "w") {|f| f.write(Process.pid) }
  File.chmod(0644, DBOMATIC_PID_FILE)

  parser = Nokogiri::XML::SAX::PushParser.new CondorEventLog.new

  # XXX hack, condor event log doesn't seem to have a top level element
  # enclosing everything else in the doc (as standards conforming xml must).
  # Create one for parsing purposes.
  parser << "<events>"

  parse_log_file(parser) if File.exists? CONDOR_EVENT_LOG_FILE
  logger.info "Parsed existing event log file - current postition: #{get_log_file_pos}"

  # track the modification time of the file for changes
  logfile_timestamp = File.mtime(CONDOR_EVENT_LOG_FILE)

  logger.info "Beginning main event loop"
  while true
    sleep 2
    logger.debug "Checking for condor event log modification"
    if File.mtime(CONDOR_EVENT_LOG_FILE) > logfile_timestamp
      logger.info "EventLog modification event triggered, parsing log"
      begin
        logfile_timestamp = File.mtime(CONDOR_EVENT_LOG_FILE)
        parse_log_file parser
      rescue Exception => e
        logger.error "Parser error: #{e.backtrace.shift}: #{e.message}"
        e.backtrace.each do |step|
          logger.error "\tfrom #{step}"
        end
      end
      logger.info "EventLog modification event trigger completed, parsing finished - current position #{get_log_file_pos}"
    end
  end
  logger.info "Main event loop completed"

  parser << "</events>"
  parser.finish
  logger.info "Finished parsing, now exiting"
rescue Exception => e
  logger.error "#{e.backtrace.shift}: #{e.message}"
  e.backtrace.each do |step|
    logger.error "\tfrom #{step}"
  end
end
