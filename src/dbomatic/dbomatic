#!/usr/bin/ruby
# Copyright (C) 2010 Red Hat, Inc.
# Written by Mohammed Morsi <mmorsi@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.  A copy of the GNU General Public License is
# also available at http://www.gnu.org/copyleft/gpl.html.

$: << File.join(File.dirname(__FILE__), "../dutils")

require 'rubygems'
require 'dutils'
require 'nokogiri'
require 'rb-inotify'
require 'optparse'

help = false
daemon = true
condor_event_log_dir    =   "/var/log/condor"
dbomatic_run_dir        =   "/var/run/deltacloud-aggregator"
dbomatic_log_dir        =   "/var/log/deltacloud-aggregator"
dbomatic_pid_dir        =   "/var/run/deltacloud-aggregator"

optparse = OptionParser.new do |opts|

  opts.banner = <<BANNER
Usage:
dbomatic [options]

Options:
BANNER
  opts.on( '-f', '--pid-file PATH', "Use PATH to the dbomatic pid directory (defaults to #{dbomatic_pid_dir})") do |newpath|
    dbomatic_pid_dir = newpath
  end
  opts.on( '-h', '--help', '') { help = true }
  opts.on( '-l', '--log PATH', "Use PATH to the dbomatic log directory (defaults to #{dbomatic_log_dir}).  Use '-' for stdout") do |newpath|
    dbomatic_log_dir = newpath
  end
  opts.on( '-n', '--nodaemon', 'Do not daemonize (useful in combination with -l for debugging)') { daemon = false }
  opts.on( '-p', '--path PATH', "Use PATH to the condor log directory (defaults to #{condor_event_log_dir})") do |newpath|
    condor_event_log_dir = newpath
  end
  opts.on( '-r', '--run PATH', "Use PATH to the dbomatic runtime directory (defaults to #{dbomatic_run_dir})") do |newpath|
    dbomatic_run_dir = newpath
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  puts "Invalid option #{e.args}"
  puts
  puts optparse
  exit(1)
end

if help
  puts optparse
  exit(0)
end

CONDOR_EVENT_LOG_FILE   =   "#{condor_event_log_dir}/EventLog"
EVENT_LOG_POS_FILE      =   "#{dbomatic_run_dir}/event_log_position"
if dbomatic_log_dir == '-'
  DBOMATIC_LOG_FILE = STDOUT
else
  DBOMATIC_LOG_FILE = "#{dbomatic_log_dir}/dbomatic.log"
end

logger = Logger.new(DBOMATIC_LOG_FILE)
logger.level = Logger::DEBUG
logger.info "DBOmatic starting up"

# daemonize
if daemon
  # note that this requires 'active_support', which we get for free from dutils
  Process.daemon
end

# Handle the event log's xml
class CondorEventLog < Nokogiri::XML::SAX::Document
  attr_accessor :tag, :event_type, :event_cmd, :event_time, :trigger_type, :grid_resource, :execute_host, :hold_reason, :private_addresses, :public_addresses

  def initialize(logger)
    @logger = logger
  end

  # Store the name of the event log attribute we're looking at
  def start_element(element, attributes)
    @tag = attributes[1] if element == "a"
  end

  # Store the value of the event log attribute we're looking at
  def characters(string)
    unless string.strip == ""
      if @tag == "MyType"
        @event_type = string
      elsif @tag == "Cmd"
        @event_cmd = string
      elsif @tag == "EventTime"
        @event_time = string
      elsif @tag == "TriggerEventTypeName"
        @trigger_type = string
      elsif @tag == "GridResource"
        @grid_resource = string
      elsif @tag == "ExecuteHost"
        @execute_host = string
      elsif @tag == "HoldReason"
        @hold_reason = string
      elsif @tag == "DeltacloudPublicNetworkAddresses"
        @public_addresses = string
      elsif @tag == "DeltacloudPrivateNetworkAddresses"
        @private_addresses = string
      end
    end
  end

  def update_instance_state_event(inst)
    if @trigger_type == "ULOG_GRID_SUBMIT"
      inst.state = Instance::STATE_PENDING
    elsif @trigger_type == "ULOG_JOB_ABORTED" or @trigger_type == "ULOG_JOB_TERMINATED"
      inst.state = Instance::STATE_STOPPED
    elsif @trigger_type == "ULOG_EXECUTE"
      inst.state = Instance::STATE_RUNNING
    elsif @trigger_type == "ULOG_SUBMIT"
      # ULOG_SUBMIT happens when the job is first submitted to condor.
      # However, it's not a state that we care to export to users, but it's
      # also not an error, so we just silently ignore it.
    elsif @trigger_type == "ULOG_JOB_HELD"
      # The job has some error condition.
      #
      # FIXME: we also may want to delete this job from condor, depending
      # on the error.  For instance, if you are trying to start an instance
      # with a mismatched image and hardwareprofile architecture, the only
      # reasonable way out is to create a new instance.  Needs thought.
      #  - I've added a condormatic_instance_reset_error() method to reset
      #    error conditions such as this.  In the future we should give different
      #    options based on the error condition.
      # FIXME: Right now we don't parse out the HoldReason (or HoldReasonCode)
      # so for now I'm going to set this to STATE_ERROR as there are multiple
      # possible reasons for going into the 'held' state.
      #
      # FIXME: This only adds the error to the instance 'last_error' field.  We
      # should really be logging this information into the event log but that is not
      # set up at this time so for now this will do.
      inst.last_error = @hold_reason
      inst.state = Instance::STATE_ERROR
    else
      @logger.info "Unexpected trigger type #{@trigger_type}, not updating instance state"
      return
    end

    begin
      inst.save!

      InstanceEvent.create! :instance => inst,
                            :event_type => inst.state,
                            :event_time => @event_time
    rescue => e
      @logger.error "#{e.backtrace.shift}: #{e.message}"
      e.backtrace.each do |step|
        @logger.error "\tfrom #{step}"
      end
    end
  end

  def update_instance_cloud_id(inst)
    # The GridResource/ExecuteHost string looks like this:
    # dcloud http://localhost:3001/api <username> <password> <image_name> <instance_name> <realm_name> <hardware_profile_name>

    if !@grid_resource.nil?
      resource = @grid_resource
    elsif !@execute_host.nil?
      resource = @execute_host
    else
      @logger.info "Unexpected nil GridResource/ExecuteHost field, skipping cloud id update"
      return
    end

    args = resource.split
    link = args[1]
    username = args[2]
    password = args[3]
    if link.nil? or username.nil? or password.nil?
      @logger.error "Unexpected nil data from #{resource}, skipping cloud id update"
      return
    end

    provider = Provider.find(:first, :conditions => ['url = ?', link])
    if provider.nil?
      @logger.error "Could not find the provider with link #{link}, skipping cloud id update"
      return
    end

    cloud_account = CloudAccount.find(:first, :conditions => ['provider_id = ? AND username = ? AND password = ?', provider.id, username, password])
    if cloud_account.nil?
      @logger.error "Could not find the cloud account corresponding to #{link}, skipping cloud id update"
      return
    end

    inst.cloud_account_id = cloud_account.id

    # FIXME: we are updating the instance_key_id here, but this is really not
    # the right way or place to do this.  This will have to be revisited when
    # we come up with a real key management architecture
    inst.instance_key_id = cloud_account.instance_key.id

    inst.save!
  end

  def update_instance_addresses(inst)
    inst.public_addresses = @public_addresses
    inst.private_addresses = @private_addresses
    inst.save!
  end

  # Create a new entry for events which we have all the neccessary data for
  def end_element(element)
    begin
      if element == "c" and @event_type == "JobAdInformationEvent" and !@trigger_type.nil?

        inst = Instance.find(:first, :conditions => ['condor_job_id = ?', @event_cmd])
        if inst.nil?
          @logger.info "Unexpected nil instance, skipping..."
        else
          update_instance_state_event(inst)
          update_instance_cloud_id(inst)
          update_instance_addresses(inst)
        end
        @tag = @event_type = @event_cmd = @event_time = @trigger_type = @grid_resource = @execute_host = @hold_reason = @public_addresses = @private_addresses = nil
      end
    rescue => e
      @logger.error "#{e.backtrace.shift}: #{e.message}"
      e.backtrace.each do |step|
        @logger.error "\tfrom #{step}"
      end
    end
  end
end

def parse_log_file(log_file, parser)
  while s = log_file.gets
    parser << s
  end
  File.open(EVENT_LOG_POS_FILE, 'w') { |f| f.write log_file.pos.to_s }
end

begin
  DBOMATIC_PID_FILE = "#{dbomatic_pid_dir}/dbomatic.pid"
  FileUtils.mkdir_p File.dirname(DBOMATIC_PID_FILE)
  open(DBOMATIC_PID_FILE, "w") {|f| f.write(Process.pid) }
  File.chmod(0644, DBOMATIC_PID_FILE)

  parser = Nokogiri::XML::SAX::PushParser.new(CondorEventLog.new(logger))

  # XXX hack, condor event log doesn't seem to have a top level element
  # enclosing everything else in the doc (as standards conforming xml must).
  # Create one for parsing purposes.
  parser << "<events>"

  notifier = INotify::Notifier.new
  log_file = nil

  if File.exists? CONDOR_EVENT_LOG_FILE
    log_file = File.open(CONDOR_EVENT_LOG_FILE)

    # persistantly store log position in filesystem
    # incase of dbomatic restarts
    if File.exists?(EVENT_LOG_POS_FILE)
      File.open(EVENT_LOG_POS_FILE, 'r') { |f| log_file.pos = f.read.to_i }
      logger.info "Replaying old events..."
      parse_log_file log_file, parser
      logger.info "done"
    end

    # Setup inotify watch for condor event log
    notifier.watch(CONDOR_EVENT_LOG_FILE, :modify){ |event|
      parse_log_file log_file, parser
    }

    # if log file doesn't exist wait until it does
  else
    notifier.watch(condor_event_log_dir, :create){ |event|
      if event.name == "EventLog"
        log_file = File.open(CONDOR_EVENT_LOG_FILE)
        parse_log_file log_file, parser

        # Setup inotify watch for condor event log
        notifier.watch(CONDOR_EVENT_LOG_FILE, :modify){ |event|
          parse_log_file log_file, parser
        }
      end
    }
  end

  while true
    begin
      notifier.run
    rescue => e
      logger.error "#{e.backtrace.shift}: #{e.message}"
      e.backtrace.each do |step|
        logger.error "\tfrom #{step}"
      end
    end
  end

  parser << "</events>"
  parser.finish
rescue => e
  logger.error "#{e.backtrace.shift}: #{e.message}"
  e.backtrace.each do |step|
    logger.error "\tfrom #{step}"
  end
end
